---
layout: post
title: Dissecting The Bug
author: bill shelton
published: true
---

h1. {{ page.title }}

p(meta). 30 January, 2010 - Alexandria, VA, by {{page.author}}

h2. Shifting gears

!>{{ site.images }}/gears.jpg!

Attending school forces me into a different mind-set, requiring me to slow down and really think hard about abstract concepts, rather than just fixing bugs as quickly as possible. I like this. It's also very inspiring to sit in class and listen. It's been a while and I've forgotten, but it's kind of like being in a conference session without the glitz and knowing it's going on for several hours, days, and months, vs. a mere 50 minutes.  I was impressed, too, by my professor, Paul Ammann, who's very smart, skilled, and understands the practical needs of technology. This is key&mdash;having professors who don't acknowledge what practitioners _have_ to do to stay employed shows a lack of understanding. Paul, on the other hand, demonstrates a keen grasp of this important concept. Many students, myself included, see value in the abstract, but also need to apply concrete concepts in order to put food on the table and clothes on the kids. Case in point, almost to the minute my job agreed to pay for this class, I got a new project: "Bill, we want you to automate the testing for Project XYZ, our highest priority project".  Little do they know that this course is _not_ about automating testing&mdash;it's about good test design, which, of course, is fundamental to any good quality assurance efforts.

So, in the most recent class (#2), we discussed a single software fault in painstaking detail. It was dissection. The main concept was _observability_ and it's antithesis. 


{{site.sp}}
{{site.sp}}

<br/>
<br/>
<br/>


!>{{ site.images }}/rip.jpg!

<br/>
<br/>


h4. RIP Observability Model

This model articulate 3 things that must happen in order for a software fault to be observable.  

* Reachability - the fault in the code has to be reachable
* Infection - the code has to put the program into an error state. This does _not_ necessarily mean the program will return incorrect results. And this is an important distinction! Just because a program is in an error state does not mean that it will _always_ produce the wrong result. _see below_ 
* Propagation - the program needs to exhibit incorrect behavior; e.g., incorrect outputs or behavior; e.g., throwing an unspecified exception

A program can exhibit 0-2 of these attributes, but in order for it to be _observable_ *all* these criteria need to be met.



<br />

h3. Dissecting The Bug

This code looks simple, and it is, but grasping the RIP concepts in the context of simple code like this is needed.  This is not the same code we covered in class, but it is in "the book":http://books.google.com/books?id=leokXF8pLY0C&dq=introduction+to+software+testing&printsec=frontcover&source=bn&hl=en&ei=WVFjS-SfK8PklAehjYm0Aw&sa=X&oi=book_result&ct=result&resnum=4&ved=0CBsQ6AEwAw#v=onepage&q=&f=false.

<pre class="brush: java;">

/**
*
* Effects: returns the index of the last element that matches y, else returns -1
*
* @returns int
* @throws NullPointerException
*/
public int lastIndexOf(int[] x, int y) {

		for (int i = x.length-1; i > 0; i--){
			if( x[i]==y ) return i;
		}
		
		return -1;
	}

</pre>

A typical JUnit test for this would look something like following and the test fails, but why?

<pre class="brush: java;">
@Test
public void testLastIndexOf(){
   int expected = 0;
   int[] x = new int[3];
   int[0] = 2; 
   int[1] = 3; 
   int[2] = 4;
   int y = 2;
   int actual = theClass.lastIndexOf(x,y);
  Assert.assertEquals( expected, actual );
  }
</pre>

See the bug?

<p></p>

It's not hard to find simply by looking closely at the code. But if this were burried in the stack and in the real world, we would simple change the @>@ to @>=@ pat ourselves on the back for swatting the fly and go on to the next one.  But with a more rigorous academic approach, we want to understand a few more things&mdash;_state_ and what makes this particular defect observable or not.

In the RIP model in order for the fault to be observable, it needs to satisfy all three criteria. It's also helpful proof to show cases (test cases) where the fault is _not_ observable, yet puts the program in an error state. How can a program be in an error state and not output an error? These are the kinds of bugs many of have wrestled with&mdash;the kind of bug that only gnashes its mandibles under certain circumstances. 

The questions to ask are (and these are taken from "the book":http://books.google.com/books?id=leokXF8pLY0C&dq=introduction+to+software+testing&printsec=frontcover&source=bn&hl=en&ei=WVFjS-SfK8PklAehjYm0Aw&sa=X&oi=book_result&ct=result&resnum=4&ved=0CBsQ6AEwAw#v=onepage&q=&f=false) :
 * in what case(s) would the inputs cause execution of the of the fault, yet not propagate? 
 * in what case(s) would the fault _not_ get execute?
 * in what cases would the fault get executed and propagate
 * in what cases would the fault get executed and create and error state?
 * in what cases would the fault get execute and _not_ create and error state?
 
 If you're still reading my guess is that you want to know how you can execute a fault and be in an error state. First, let's define what state is.  State can be defined as a combination of variable and value pairs and the program counter (PC) - this is where the code _should be_ executing. Example: <br />
 
 
 S ~0~ -> S ~1~ -> S ~2~ -> S ~3~  -> S ~4~  -> S ~5~ 
 
 
But, sometimes the program _skips_ a state and goes from S ~3~  -> S ~5~ 

In S ~0~ we're entering the method and we have the values of x and y. In S ~1~ we're now at @for(int i = x.length-1;@ and our state now we have a value for @i@.	Now, if what if we have a single element array; e.g., x = 1? Because it's only one element, this gives @i@ the value of 0, so we never execute the fault @i > 0@, yet the program returns the correct result, -1. The *error state*, and this is the take-home, is the fact that the PC never reaches the @if( x[i] == y)@ statement.

See, I do get it :-) now I just need to be more awake for the next quiz.  

_note: not quite finished with this post_

 