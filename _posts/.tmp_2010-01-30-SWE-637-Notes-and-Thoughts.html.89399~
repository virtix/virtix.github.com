<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/></head><body><p>---<br/>layout: post<br/>title: Dissecting The Bug<br/>author: bill shelton<br/>published: true<br/>---</p><h1 id="page.titleDRAFT">{{ page.title }}  ::DRAFT::</h1><p class="meta">30 January, 2010 &#8211; Alexandria, VA, by {{page.author}}</p><h2 id="Shiftinggears">Shifting gears</h2><p><img align="right" border="0" src="{{ site.images }}/gears.jpg"/></p><p>Attending school forces me into a different mind-set, requiring me to slow down and really think hard about abstract concepts, rather than just fixing bugs as quickly as possible. I like this. It&#8217;s also very inspiring to sit in class and listen. It&#8217;s been a while and I&#8217;ve forgotten, but it&#8217;s kind of like being in a conference session without the glitz and knowing it&#8217;s going on for several hours, days, and months, vs. a mere 50 minutes.  I was impressed, too, by my professor, Paul Ammann, who&#8217;s incredibly smart, skilled, and understands the practical needs of technology. This is key&amp;mdash;having professors who don&#8217;t acknowledge what practitioners <em>have</em> to do to stay employed shows a lack of understanding. Paul, on the other hand, demonstrates a keen grasp of this important concept. Many students, myself included, see value in the abstract, but also need to apply concrete concepts in order to put food on the table and clothes on the kids. Case in point, almost to the minute my job agreed to pay for this class, I got a new project: &#8220;Bill, we want you to automate the testing for Project XYZ, our highest priority project&#8221;.  Little do they know that this course is <em>not</em> about automating testing&amp;mdash;it&#8217;s about good test design, which, of course, is fundamental to any good quality assurance efforts.</p><p>Ok, enough about me ...</p><p>So, in the most recent class (#2), we discussed a single software fault in painstaking detail. It was dissection, the main concepts being <em>observability</em> and it&#8217;s antithesis.  These are my notes, but with some reflection and practice.</p><p><p>&amp;nbsp;</p><br/><br/></p><p><img align="right" border="0" src="{{ site.images }}/rip.jpg"/></p><p><br/><br/><br/></p><h4 id="RIPObservabilityModelcitationneeded">RIP Observability Model   <em>(citation needed)</em></h4><p>This model articulate 3 properties that must must exist in a program execution in order for a software fault to be observable.  </p><ul><li><strong>Reachability</strong> - the fault in the code has to be reachable</li><li><strong>Infection</strong> - the fault has to put the program into an error state. This does <em>not</em> necessarily mean the program will return incorrect results&amp;mdash;this is an important distinction! Just because a program is in an error state does not mean that it will <em>always</em> produce the wrong result. <em>see below</em> </li><li><strong>Propagation</strong> - the program needs to exhibit incorrect behavior; e.g., incorrect outputs or behavior; e.g., throwing an unspecified exception</li></ul><p>A program can exhibit zero, one, or two of these properties, but in order for it to be <em>observable</em> <strong>all</strong> these criteria need to be met.</p><p><br /></p><h3 id="Dissection">Dissection</h3><p>This code looks simple, and it is, but using  simple code helps in grasping the RIP concepts.  This is not the same code we covered in class, but it is in <a href="http://books.google.com/books?id=leokXF8pLY0C&amp;dq=introduction+to+software+testing&amp;printsec=frontcover&amp;source=bn&amp;hl=en&amp;ei=WVFjS-SfK8PklAehjYm0Aw&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=4&amp;ved=0CBsQ6AEwAw#v=onepage&amp;q=&amp;f=false">the book</a>. The code has a bug; try to find it ...</p><p><pre class="brush: java;"></p><p>/**<br/>*</p><ul><li>Effects: returns the index of the last element that matches y, else returns -1</li></ul><p>*</p><ul><li>@returns int</li><li>@throws NullPointerException</li></ul><p>*/<br/>public int lastIndexOf(int[] x, int y) {</p><p>		for (int i = x.length-1; i > 0; i--){<br/>			if( x[i]==y ) return i;<br/>		}</p><p>	return -1;<br/>}<br/></pre></p><p>A typical JUnit test for this would look something like following and the test fails, but why?</p><p><pre class="brush: java;"><br/>@Test<br/>public void testLastIndexOf(){<br/>   int expected = 0;<br/>   int[] x = new int<sup class="footnote"><a href="#___fn3">3</a></sup>;<br/>   int<sup class="footnote"><a href="#___fn0">0</a></sup> = 2; <br/>   int<sup class="footnote"><a href="#___fn1">1</a></sup> = 3; <br/>   int<sup class="footnote"><a href="#___fn2">2</a></sup> = 4;<br/>   int y = 2;<br/>   int actual = theClass.lastIndexOf(x,y);<br/>  Assert.assertEquals( expected, actual );<br/>  }<br/></pre></p><p>See the bug?</p><p><p></p></p><p>It&#8217;s not hard to find simply by looking closely at the code. But if this were burried in some stacktrace it would be much harder to locate&amp;mdash;here we already know where it is, within a few lines of code. In the real world, we would simple change the <code>></code> to <code>>=</code>, pat ourselves on the back for swatting the fly, and go grab some Fritoes.  But with a more rigorous academic approach, we have an opportunity to grasp a few more concepts&amp;mdash;<em>state</em> and what makes this particular defect observable or not.</p><p>The RIP model states that in order for the fault to be observable, it needs to satisfy all three criteria&amp;mdash;Reachability, Infection, and Propagation. It&#8217;s also helpful to show cases (test cases) where the fault is <em>not</em> observable, yet puts the program in an error state. How can a program be in an error state and not output an error? These are the kinds of bugs many of us have wrestled with&amp;mdash;the kind of bug that gnashes its sharp mandibles only under certain circumstances. </p><p>| The questions to ask are (and these are loosely taken from <a href="http://books.google.com/books?id=leokXF8pLY0C&amp;dq=introduction+to+software+testing&amp;printsec=frontcover&amp;source=bn&amp;hl=en&amp;ei=WVFjS-SfK8PklAehjYm0Aw&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=4&amp;ved=0CBsQ6AEwAw#v=onepage&amp;q=&amp;f=false">the book</a>) :<br/> * in which case(s) would the fault <em>not</em> execute?<br/> * in which case(s) would the fault execute yet <em>not</em> create an error state?<br/> * in which case(s) would the fault execute and create an error state, but not propagate?<br/> * in which case(s) would the inputs cause execution of the of the fault, cause an error state, and propagate? <br/>  | <img align="right" border="0" src="{{site.images}}/Brain_1.jpg"/> |</p><br />If you&#8217;re still reading my guess is that you want to know how you can execute a fault, be in an error state, yet not propagate. First, let&#8217;s define what state is.  State can be defined as a combination of variable and value pairs plus the program counter (PC) &amp;mdash; this is where the code <em>should be</em> executing. Example: <br />S <sub>0</sub> -> S <sub>1</sub> -> S <sub>2</sub> -> S <sub>3</sub>  -> S <sub>4</sub>  -> S <sub>5</sub> <p>But, sometimes the program <em>skips</em> a state and goes from S <sub>3</sub>  -> S <sub>5</sub> </p><p>In S <sub>0</sub> we&#8217;re entering the method and we have the values of x and y. In S <sub>1</sub> we&#8217;re now at <code>for(int i = x.length-1; ...)</code> and our state now we have a value for <code>i</code>.	What if we have a single element array; e.g., x = 1? Because it&#8217;s only one element, this gives <code>i</code> the value of 0, so we never get past the fault <code>i > 0</code>, and the program returns the correct result, -1. The <strong>error state</strong>, and this is the take-home, is the fact the PC never reaches the <code>if( x[i] == y )</code> statement. The state analysis for this input should look something like this:</p><p><pre><br/>Expected State    		Actual State<br/>------------------------------------------------------------------------------------<br/> x = [ 1 ]			x = [ 1 ]    <br/> y = 2          		y  = 2<br/> i = 0       			i = 0     <br/> PC =  if( x[i]==y )       	PC = return -1;     <br/></pre></p><p>In simple terms, this is just saying the code didn&#8217;t do what it was supposed to, because it never evaluated the conditional expression <code>if ( x[i]==y )</code>.  </p><p>Chances are, in practice, you would never go into this much detail about such a small fault. This is, for me, taking an opportunity to think about bugs, or software faults, in abstract terms. Which, is not only a great exercise, but, a useful and practical way to reason about the complexities of building software. We&#8217;re not constrained by a particular language implementation, or platform, and dealing with abstractions such as this transcends much of the industry noise and helps us to focus on the principals of software quality, rather than the software itself.</p><p>Next up. (And I&#8217;m totally geeking out over this!) Coverage Criteria.</p><p>Test and Be Happy!</p><p>bill shelton</p></body></html>