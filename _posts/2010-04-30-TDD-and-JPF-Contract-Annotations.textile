---
layout: post
title: Testing with Java Path Finder Contract Annotations
published: true
draft: false
draft_message: 
pub_date: April 30, 2010
---

{% if page.draft %} %(draft){{ page.draft_message  }}%  {%endif%}

h1. {{ page.title }}


p(meta). {{ page.pub_date }}  - {{site.location}}
Last Modified:  {{ site.time | date:  "%A, %B %d, %Y - %I:%M %p %Z" }}


h2. Design by Contract (DbC)

<p />

|^.Bertrand Myer coined a metaphorical concept with respect to the Eiffel language and OO&mdash;Design By Contract or DbC, and it has it's roots in "Hoare's Triple":http://en.wikipedia.org/wiki/Hoare_logic#Hoare_Triple. Informally, DbC states that given a precondition, a program will guarantee a postcondition. If the precondition is _not_ met, the program will fail hard (throw an exception). 
<BR/>One key point with DbC is that satisfying the precondition is the responsibility of the client, not the provider. This means the provider may perform validation, but , the provider is simply not in the business of _correcting_ the inputs. The provider  inspects the inputs (as well as the outputs to guarantee the contract), but DbC says that it's the client who _ensures_ the precondition and the provider who _guarantees_ the postcondition. |^. !{{site.images}}/eraserhead-2.jpg! |

In Java we can use Javadoc to help articulate the contract:

<pre class="brush: java">
public class Contract  {

	/**
	 * Applies a payment on behalf of the specified Account.
	 * 
	 * @param account an Account object
	 * @param amount the amount to withdraw from an account.
	 * @throws NullPointerException
	 * 
	 * */
	public double makePayment(Account account, double amount)  {
	    account.setBalance(amount);
		return account.getBlance();
	}

}	
</pre>

We're not concerned just about the mechanics of how a payment is submitted, but rather, we want to see how the contract is honored and how we can test it. 

h2. Testing the Contract

It doesn't take too much effort to see that our unit tests are simply testing that contract. This is true for most unit tests&mdash;unit tests test the _contract_ specified by the API.

<pre class="brush: java">

 	@Test
	public void testMakePayment() {
		double amount = 0.01;
		double actual = contract.makePayment(account, amount);
		assertEquals(99.99, actual, 0.01); 
	}

</pre>

The example may look so typical and simple the ambiguities may not be immediately obvious. But there're a number of unarticulated assumptions. Namely, the contract here is only considering _normal_ inputs and does not give much indication in the way of exceptional behavior. What if @amount@ is negative? What is an allowable balance for an @Account@&mdash;0,<0 ? Neither of these (or other questions) are addressed in the specification. 

To add some clarity, let's say that payments must be a positive number and the account can't be null. If those preconditions are not met, we'll throw an exception. Better?  

<pre class="brush: java">
@Test(expected=NullPointerException.class)
	public void nullAccountShouldThrowNPE() {
		double amount = 0.01;
		double actual = contract.makePayment(null, amount);
	}
	
	
</pre>

Let's add some clarity to this by way of testing:


<pre class="brush: java">
</pre>

h2. TDD

From a TDD perspective, we've done pretty good. We've written a number of tests prior to our  production code and the tests also serve as the specs. And the tests are telling us what we need to do. The most obvious next steps would be to place some code at the top of the method that does some checking and throws the appropriate exception(s).  The nature of the tests suggests a blacklist approach, but that could be a nightmare to manage down  the road. There's something else possible :


h2. Java Path Finder ("http://babelfish.arc.nasa.gov/trac/jpf/wiki/WikiStart":http://babelfish.arc.nasa.gov/trac/jpf/wiki/WikiStart)

!<{{site.images}}/saturn5_apollo11.gif!

NASA has begun to open source some of their software. In particular, the Ames Research Lab in San Jose, CA, has a number of interesting projects. Java Path Finder (JFP) is one that, although around for some time, is new to me. It started out as a model checking tool, but has evolved into much more. I'm not going to go into too many details, but essentially, there's a JPF core and a number of sub-projects, or plugins. What they have built for software testing and verification is mind blowing. The docs are thin, but the examples are good and non-trivial. 


The one component of interest here is the "jpf-aprop":http://babelfish.arc.nasa.gov/trac/jpf/wiki/projects/jpf-aprop, or JPF Annotation Properties for specifications.  The core aspects of our tests remain, but our implementation changes. For the Contract class, it now looks like this:

<br />
<br />
<br />
<br />
<br />
<br />


 


   

(Coincidentally, both Bertrand and Tony are giving keynotes at "TAIC PART":http://www2010.taicpart.org/index.html in September 2010). 


