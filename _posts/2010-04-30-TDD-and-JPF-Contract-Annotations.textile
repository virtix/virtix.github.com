---
layout: post
title: Exploring Testing with Java Path Finder Contract Annotations
published: true
draft: true
draft_message: 
pub_date: April 30, 2010
---

{% if page.draft %} %(draft){{ page.draft_message  }}%  {%endif%}

h1. {{ page.title }}


p(meta). {{ page.pub_date }}  - {{site.location}}
Last Modified:  {{ site.time | date:  "%A, %B %d, %Y - %I:%M %p %Z" }}


_This is some exploratory writing. Omissions abound and wires are sprawling ... Additionally, the example is trivial._

h2. Design by Contract (DbC)

<p />

By way of some background, 	"Bertrand Myer":http://se.ethz.ch/~meyer/ coined a metaphorical concept with respect to the Eiffel language and OO&mdash;"Design By Contract":http://en.wikipedia.org/wiki/Design_by_contract or DbC. <!--, and it has it's roots in "Hoare's Triple":http://en.wikipedia.org/wiki/Hoare_logic#Hoare_Triple.--> Informally, DbC states that given a precondition, a program will guarantee a postcondition. If the precondition is _not_ met, the program will fail hard (throw an exception).  It's an elegant and simple concept first defined by C. A. Hoare, and now known as _Hoare's Triple_ : 
!>{{site.images}}/52d51d706efe0ebb8a0974181c1f8e4a.png!:http://en.wikipedia.org/wiki/Hoare_logic#Hoare_Triple

One key point with DbC is that satisfying the precondition is the responsibility of the client, not the provider. This means the provider may perform validation, but , the provider is simply not in the business of _correcting_ the inputs. The provider  inspects the inputs (as well as the outputs) to guarantee the contract, but DbC says that it's the client who _ensures_ the precondition and the provider who _guarantees_ the postcondition. 

!>{{site.images}}/eraserhead-2.jpg!

In Java we can use Javadoc to specify the contract:

<div style="max-width:720px">
<pre class="brush: java" >
public class Account  {
 double balance;
	/**
	 * Applies a payment on behalf of the Account.
	 * 
	 * @param amount the amount to withdraw from an account.
	 * 
	 * */
	public double makePayment(double amount)  {
		this.balance -= amount;
		return this.balance;
	}

}	
</pre>
</div>

The metadata about the return type and @@param@ imply what the contract is (though it's weak).

h2. Testing the Contract

It doesn't take too much effort to see that our unit tests are simply testing that contract. This is true for most unit tests&mdash;unit tests test the _contract_ specified by the API.

<pre class="brush: java">

 	@Test
	public void testMakePayment() {
		//Assume a balance of 100.00 ...e.g., new Account(100.00)
		double amount = 0.01;
		double actual = account.makePayment(amount);
		assertEquals(99.99, actual); 
	}

</pre>


The example may look so typical and simple the ambiguities may not be immediately obvious. But there're a number of problematic assumptions. Namely, the contract here is only considering _normal_ inputs and does not give much indication in the way of the state of @Account@ or exceptional behavior. For example, what if @amount@ is negative? What is an allowable balance for an @Account@? Zero , less than Zero ? Neither of these (or other questions) are addressed in the example specification.

Our test is a step towards formulating our specification. However, we still would like to know when an invalid state is reached in the @Account@ object. Better yet, we should allow only _valid_ states to be reached. Shifting back to our production code. this can be articulated as a "class invariant":http://en.wikipedia.org/wiki/Class_invariant.  "Barbara Liskov":http://en.wikipedia.org/wiki/Liskov presented the concept of a _Representation Invariant_  which defines the domain of the abstraction function. Again, we can use Javadoc to specify what a legal state should be in our class.

<div style="max-width:900px">
<pre class="brush: java" >
/** 
* @Invariant  balance must be >= $0.00
*
*/
public class Account  {
...
}	
</pre>
</div>

This is a specification written more or less in a natural language and it leaves room for interpretation. There's also no automatic way of testing the state of this class yet or a way to enforce this. One obvious approach would be to create an accessor method (@getBallance()@) and throw an exception if @getBallance()@ ever returns less than 0.  Assuming our real class is much larger than what's presented, this would require the @getBalance()@  to be in any place in our Account that alters the balance field; this may evolve into _too_ many places.

What we would like is (1) a way to specify the class invariant,  (2) specify the pre and post conditions for each method, and (3) be able to automatically test our contract.  
<br/>

h1. Java Path Finder ("http://babelfish.arc.nasa.gov/trac/jpf/wiki/WikiStart":http://babelfish.arc.nasa.gov/trac/jpf/wiki/WikiStart)

!>{{site.images}}/saturn5_apollo11.gif!

Interestingly, NASA has a number of "open source":http://opensource.arc.nasa.gov/ software projects. In particular, the Ames Research Lab sponsors both research and production-ready projects. Java Path Finder (JFP) (Though not listed on NASA's open source page) is one such tool.  It started out as a model checker, but has evolved into much more. Essentially, there's a "_jpf-core_":http://babelfish.arc.nasa.gov/trac/jpf/wiki/projects/jpf-core and a number of sub-projects, or _plugins_.  The package of interest here is the "jpf-aprop":http://babelfish.arc.nasa.gov/trac/jpf/wiki/projects/jpf-aprop, or JPF Annotation Properties for specifications.  As the project name suggests, this is a collection of annotations that support (DbC) specifications and testing.  Automatic unit testing is performed via JUnit and JPF listeners. We'll cover this shortly. 

The core aspects of our tests remain, but our implementation changes. For the @Account@ class, it now looks like this:


<div style="max-width:720px">
<pre class="brush: java" >
import gov.nasa.jpf.annotation.Invariant;
import gov.nasa.jpf.annotation.Ensures;
import gov.nasa.jpf.annotation.Requires;

@Invariant ("balance >= 0")
public class Account  {

	double balance;

	@Requires("amount > 0")
	@Ensures("Result >= 0")
	public double makePayment(double amount)  {
		this.balance -= amount;
		return this.balance;
	}

}	
</pre>
</div>

The new annotations @Invariant(...)@, @Requires(...)@, and @Ensures(...)@ allow us to implement DbC principals both in our code and test the contract in our associated unit tests. Theses annotations accept a "rich grammar":http://babelfish.arc.nasa.gov/trac/jpf/attachment/wiki/projects/jpf-aprop/contract/ContractSpec.g. If simple expressions aren't enough (and they never seem to be), JPF allows you to implement a class to perform the validation ( see @MyStrongPostCondition@ below and "http://babelfish.arc.nasa.gov/trac/jpf/wiki/projects/jpf-aprop/contract":http://babelfish.arc.nasa.gov/trac/jpf/wiki/projects/jpf-aprop/contract) :

<pre class="brush: java" >
package blog;

import gov.nasa.jpf.annotation.Invariant;
import gov.nasa.jpf.annotation.Ensures;
import gov.nasa.jpf.annotation.Requires;
import gov.nasa.jpf.annotation.SandBox;
import gov.nasa.jpf.aprop.Predicate;

@Invariant ("balance >= 0")
public class Account  {

	private double balance;
	
	public Account(double initialBallance){
		this.balance = initialBallance;
	}
	

	@Requires("amount > 0")
	@Ensures("Result satisfies MyStrongPostCondition")
	public double makePayment(double amount)  {
		this.balance -= amount;
		return this.balance;
	}

	@SandBox // Constraint annotation to guarantee no side effects.
	static class MyStrongPostCondition implements Predicate {
	    public String evaluate (Object testObj, Object[] args) {
	    	double postCondition = Double.parseDouble(testObj.toString());
	    	String results = null;
	    	if (postCondition < 0) results = "makePayment(...) would cause a balance to be less than 0. Actual value was : " + postCondition;
	    	return results;
	    }
	  }
	

}	//end class



</pre>

Though our inner class here still implements the simple string expression, you can see how more complex validations can be performed. Note that we import @@Sandbox@ and @Predicate@. Also note the keyword @Result@ in the @@Ensures@ expression. This applies to any value (post-condition) returned by the method under test.

<br /><br />

h2. Testing The Contract

To wire this into JUnit, we create a JPF unit test and by extending 	@gov.nasa.jpf.util.test.TestJPF@. Note that this _is_ a JUnit type. Additionally, we specify a JPF listener to use when testing. See the @JPF_ARGS@ field. What feels strange is adding a @main()@ method to the test case, but this is required to run the tests. Additionally, we need to call a _verifier_. In this case, we're using the @verifyNoPropertyViolation(...)@ method. This is a departure from typical JUnit testing.


<pre class="brush: java">
package blog;

import gov.nasa.jpf.util.test.TestJPF;
import org.junit.Test;

public class AccountTest extends TestJPF {

	static final String[] JPF_ARGS = { "+listener=.aprop.listener.ContractVerifier", 
        "+log.info=gov.nasa.jpf.aprop",
        "+cg.enumerate_random" };

	
	//--- driver to execute single test methods
	public static void main(String[] args) {
		runTestsOfThisClass(args);
	}

	
	@Test
	public void testMakePayment(){
		if (verifyNoPropertyViolation(JPF_ARGS)) {
			Account account = new Account(100.00);
			account.makePayment(20.00);
		}
	}
	
	
	
	@Test
	public void testInvalidInvariant(){
		if (verifyNoPropertyViolation(JPF_ARGS)) {
			Account account = new Account(-100.00);
			account.makePayment(20.00);
		}
	}
	
	
	
}//end testcase
</pre>
<br/>


We've created two unit tests. One is a happy test; that is, one that passes as expected with typical inputs, and the other is an intentional class invariant violation. This violation demonstrates how JPF listens for what we specified and how JPF responds to the violation. Looking at the results the listener generates, the typical JUnit departure seems to be nominal: 

!(tn300)/images/eclipse-jpf1.png!

Log output:
<br/>
<code style="font-size:.85em">
running jpf with args: +listener=.aprop.listener.ContractVerifier +log.info=gov.nasa.jpf.aprop +cg.enumerate_random blog.AccountTest testMakePayment
symbolic.dp=choco
Symbolic Execution Mode
JavaPathfinder v5.x - (C) RIACS/NASA Ames Research Center

====================================================== system under test
application: blog/AccountTest.java
arguments:   testMakePayment 

====================================================== search started: 5/25/10 7:53 AM
String.valueOf3
String.trim
String.length

====================================================== results
no errors detected

====================================================== statistics
elapsed time:       0:00:00
states:             new=1, visited=0, backtracked=1, end=1
search:             maxDepth=0, constraints=0
choice generators:  thread=1, data=0
heap:               gc=1, new=311, free=22
instructions:       3902
max memory:         119MB
loaded code:        classes=83, methods=1039

====================================================== search finished: 5/25/10 7:53 AM
  running jpf with args: +listener=.aprop.listener.ContractVerifier +log.info=gov.nasa.jpf.aprop +cg.enumerate_random blog.AccountTest testFoobar
symbolic.dp=choco
Symbolic Execution Mode
JavaPathfinder v5.x - (C) RIACS/NASA Ames Research Center


====================================================== system under test
application: blog/AccountTest.java
arguments:   testFoobar 

====================================================== search started: 5/25/10 7:53 AM
String.valueOf3
String.trim
String.length
String.length

====================================================== error #1
gov.nasa.jpf.jvm.NoUncaughtExceptionsProperty
java.lang.AssertionError: postcondition violated: "makePayment(...) would cause a balance to be less than 0. Actual value was : -120.0", values={Result=-120.0}
	at blog.Account.makePayment(Account.java:23)
	at blog.AccountTest.testFoobar(AccountTest.java:39)
	at blog.AccountTest.main(AccountTest.java:18)


====================================================== results
error #1: gov.nasa.jpf.jvm.NoUncaughtExceptionsProperty "java.lang.AssertionError: postcondition violated: ..."

====================================================== statistics
elapsed time:       0:00:00
states:             new=1, visited=0, backtracked=0, end=0
search:             maxDepth=0, constraints=0
choice generators:  thread=1, data=0
heap:               gc=0, new=342, free=0
instructions:       3980
max memory:         119MB
loaded code:        classes=86, methods=1198

====================================================== search finished: 5/25/10 7:53 AM
</code>

<br />

h1. Summary 

JPF Annotation Properties for Specification offers a declarative way to specify pre and post conditions and class invariants through an expressive grammar for annotations. Additionally, the JPF listeners allow for the automatic verification of the contract specification during program execution. Performing verification as JUnit tests requires unit tests to extend @gov.nasa.jpf.util.test.TestJPF@, initialize JPF in a main method, and use a JPF verifier method.

Being able to specify the contract _and_ automatically test can be very useful, especially with respect to class invariants, where encapsulation frequently prevents such direct inspection. It would be nice to have a tighter more transparent integration with JUnit or TestNG and Eclipse. Perhaps, a set of static contract-based assertions and custom test runners would be useful. It's my understanding that JPF runs in a separate JVM than the system under test.  This may complicate implementation matters (if this is, in fact, true). With that said, the work the JPF folks have done is truly impressive with respect to jpf-aprop as well as the other JPF projects.


(Coincidentally, both Bertrand and Tony are giving keynotes at "TAIC PART":http://www2010.taicpart.org/index.html in September 2010 and JPF is a "GSOC 2010":http://code.google.com/soc/ sponsor). 


