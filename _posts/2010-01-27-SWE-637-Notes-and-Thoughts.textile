---
layout: post
title: Dissecting The Bug
author: bill shelton
published: true
---

h1. {{ page.title }}

p(meta). 29 January, 2010 - Alexandria, VA, by {{page.author}}

h2. Shifting gears

!>/images/gears.JPG!

Attending school requires a different mind-set. It requires me to slow down and really think hard about subjects, rather than just delivering solutions as quickly as possible. I like this. It's also very inspiring to sit in class and listen. It's been a while and I've forgotten, but it's kind of like being in a conference sessions without the glitz and knowing it's going on for several hours, days, and months, vs. 50 minutes.  I'm impressed, too, by my professor, Paul Ammann, who's very smart, skilled, and understands the practical needs of technology. This is key&mdash;having professors who do not acknowledge what practitioners _have_ to do to stay employed shows a lack of understanding. Paul, on the other hand, demonstrates a keen grasp of this important concept. Many students, myself included, enjoy playing in the abstract, but also need to apply these concepts in order to put food on the table and clothes on the kids. Case in point, almost to the minute my job agreed to pay for this class, I got a new project: "Bill, we want you to automate the testing for Project XYZ, our highest priority project".  Little do they know that this course is _not_ about automating testing&mdash;it's about good test design, which, of course, is fundamental to any good quality assurance efforts.

<p>&nbsp;</p>

h3. So, last night ...

!</images/swedishchef.JPG!

<p>&nbsp;</p>
I borked my first quiz, I think. The irony is that I "get" the concepts, but I do have a problem memorizing details and definitions, especially recalling the information accurately at the end of the day. For example, I probably unintentionally swapped the definitions of Validation and Verification. Hell, they both start with "V"&mdash;that should be good enough ;-) Kidding aside, testing my knowledge is not the same as testing software. Computers operate more consistently than my mind and body.  Given that same test in the morning I would have done much better, but after being up for 12 hours, a full day at work, I get saturated and fatigued. I'm not making excuses; this is just a fact. It's a good thing computers are more consistent. Imagine if computers just got tired at the end of the day and started demonstrating faults?

I don't think I've ever been a good tester and the way I learn best is by listening and repitition.

<p>&nbsp;</p>
<p>&nbsp;</p>
_So, to review:_
<p>&nbsp;</p>
<p>&nbsp;</p>


h4. RIP Observability Model

!>/images/rip.jpg!

This model articulate 3 things that must happen in order for a software fault to be observable.  

* Reachability - the fault in the code has to be reachable
* Infection - the code has to put the program into an error state. This does _not_ necessarily mean the program will return incorrect results. And this is an important distinction! Just because a program is in an error state does not mean that it will _always_ produce the wrong result. _see below_ 
* Propagation - the program needs to exhibit incorrect behavior; e.g., incorrect outputs or throwing an unspecified exception

A program can exhibit 0-2 of these attributes, but in order for it to be _observable_ all these criteria need to be met.


h3. Dissecting The Bug

This code looks simple, and it is, but grasping the RIP concepts in the context of simple code like this is needed.  This is not the same code we covered in class, but it is in the book.

<pre class="brush: java;">

/**
*
* Effects: returns the index of the last element that matches y, else returns -1
*
* @returns int
* @throws NullPointerException
*/
public int lastIndexOf(int[] x, int y) {

		for (int i = x.length-1; i > 0; i--){
			if( x[i]==y ) return i;
		}
		
		return -1;
	}

</pre>

A typical JUnit test for this would look something like following and the test fails, but why?

<pre class="brush: java;">
@Test
public void testLastIndexOf(){
   int expected = 0;
   int[] x = new int[3];
   int[0] = 2; 
   int[1] = 3; 
   int[2] = 4;
   int y = 2;
   int actual = theClass.lastIndexOf(x,y);
  Assert.assertEquals( expected, actual );
  }
</pre>

This is a hard bug to find and in the real world, we would simple change the @>@ to @>=@ pat ourselves on the back for swatting the fly and go on to the next one.  But with a more rigorous academic approach, we want to understand a few more things&mdash;_state_ and what makes this particular defect observable or not.

In the RIP model in order for the fault to be observable, it needs to satisfy all three criteria. It's also helpful proof to show cases (test cases) where the fault is _not_ observable, yet puts the program in an error state. How can a program be in an error state and not output an error? These are the kinds of bugs many of have wrestled with&mdash;the kind of bug that only gnashes its mandibles under certain circumstances. 

The questions to ask are (and these are taken from "the book":http://books.google.com/books?id=leokXF8pLY0C&dq=introduction+to+software+testing&printsec=frontcover&source=bn&hl=en&ei=WVFjS-SfK8PklAehjYm0Aw&sa=X&oi=book_result&ct=result&resnum=4&ved=0CBsQ6AEwAw#v=onepage&q=&f=false) :
 * in what case(s) would the inputs cause execution of the of the fault, yet not propagate? 
 * in what case(s) would the fault _not_ get execute?
 * in what cases would the fault get executed and propagate
 * in what cases would the fault get executed and create and error state?
 * in what cases would the fault get execute and _not_ create and error state?
 
 If you're still reading my guess is that you want to know how you can execute a fault and be in an error state. First, let's define what state is.  State can be defined as a combination of variable and value pairs and the program counter (PC) - this is where the code _should be_ executing. Example: <br />
 
 
 S ~0~ -> S ~1~ -> S ~2~ -> S ~3~  -> S ~4~  -> S ~5~ 
 
 
But, sometimes the program _skips_ a state and goes from S ~3~  -> S ~5~ 

In S ~0~ we're entering the method and we have the values of x and y. In S ~1~ we're now at @for(int i = x.length-1;@ and our state now we have a value for @i@.	Now, if what if we have a single element array; e.g., x = 1? Because it's only one element, this gives @i@ the value of 0, so we never execute the fault @i > 0@, yet the program returns the correct result, -1. The *error state*, and this is the take-home, is the fact that the PC never reaches the @if( x[i] == y)@ statement.

See, I do get it :-) now I just need to be more awake for the next quiz.  

_note: not quite finished with this post_

 